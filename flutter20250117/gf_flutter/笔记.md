1

# 函数参数中使用{}和不使用的区别.
 Future<bool> get_article_for_id({int page2=1, int fenlei_id=1})
使用了大括号 {} 包裹参数，这些参数是命名可选参数
调用时必须指定参数名称，例如：get_article_for_id(page2: 2, fenlei_id: 3)
可以只传递部分参数，例如：get_article_for_id(fenlei_id: 5)（page2 使用默认值 1）
Future<bool> get_article_for_id(int page2=1, int fenlei_id=1)
没有使用大括号，这些参数是位置可选参数
调用时可以不指定参数名称，但必须按顺序传递，例如：get_article_for_id(2, 3)
如果要跳过前面的参数使用默认值，需要显式传递 null（但在这个例子中参数有默认值，所以可以直接省略后面的参数）
例如：get_article_for_id(2) 会使用 page2=2，fenlei_id=1（默认值）

总结来说，主要区别在于参数的调用方式：命名参数需要显式指定参数名，位置参数则按位置传递。命名参数在参数较多时更清晰，尤其是当某些参数可选时。

# PageView和tabbarview该用哪个?

PageView主要是展示相同页面的容器，比如今日头条app首页，根本不同的新闻类型展示不同的新闻，但页面的布局是一样的。另外PageView还支持左右滑动，可以和TabBar做联动,PageView也可以做整体的滑动容器，比如抖音的视频上下滑动。。TabBarView主要展示不同ui的容器，配合TabBar导航，点击tab时，切换到不同的[ui界面](https://so.csdn.net/so/search?q=ui%E7%95%8C%E9%9D%A2&spm=1001.2101.3001.7020)。比如微信，有微信、**通讯录**、发现、我 4大不同的模块。

* **避免不必要的嵌套：** 只有在绝对必要时才嵌套可滚动小部件。
* **使用 `SingleChildScrollView`：** 当不需要嵌套时，使用 `SingleChildScrollView` 替代 `ListView` 或 `PageView`。**通常 `SingleChildScrollView`只应在期望的内容不会超过屏幕太多时使用** ，这是因为 `SingleChildScrollView`不支持基于 Sliver 的延迟加载模型，所以如果预计视口可能包含超出屏幕尺寸太多的内容时，那么使用 `SingleChildScrollView`将会非常昂贵（性能差），此时应该使用一些支持Sliver延迟加载的可滚动组件，如 `ListView`。
* **优化项目大小：** 确保可滚动列表中的项目大小一致，避免动态大小变化。
* **延迟加载数据：** 对于大型列表，使用延迟加载技术逐步加载项目。
* **使用 `Slivers`：** 在 `CustomScrollView` 中使用 `Slivers`，它可以提高性能并提供更精细的滚动控制。
* 

PageView是一个**可逐页滚动的列表**，和Android中ViewPage类似。 PageView有三种构造函数：

1. 默认构造函数PageView
2. PageView.builder：适用于具有大量（或无限）列表项。
3. PageView.custom：提供了自定义子Widget的能力。

作者：字节跳不动
链接：https://www.jianshu.com/p/b21486118e67
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# initstate中只有网络请求完毕后才刷新页面的方法:再build中添加一个变量isshuaxin,判断此变量为真,则显示所有页面组件,否则不显示.然后网络请求完毕后isshuaxin=true.这样网络请求不完成,initstate执行完毕后直接显示页面也会失败,因为变量值不为真.只有网络请求完毕后变量为真,才会显示页面.

 '''
   Widget build(BuildContext context) {
    print("isshow");    print(isshow);
if(isshow){ return 页面组件树;}else{

return 返回一个图片;

}

 '''

# init中顺序执行网络请求 get_data(page = 1).then((value) =>  get_zhiding());

# 20240616问题未解决 .main.dart中的页面路由代码:

 '''GetPage(
              name: '/user_index',
    page: () =>
                  const User_index()),
  '''
其中的name应该与admin_menu表的menu_url对应一致

# //user_authority0= (user_authority)此种方式,是引用传递,因此user_authority改变,user_authority0也会跟着变.改进方法用 List.from创建新的list

在Dart中，如果你将一个List（或其他可变集合类型，如Set或Map）赋值给一个新的变量，这两个变量实际上引用的是内存中的同一个对象。因此，如果你修改了这个List的内容（例如添加、删除或修改元素），那么所有引用这个List的变量都会看到这些变化。

  这是因为Dart（和许多其他编程语言一样）中的赋值操作是“按引用”进行的，而不是“按值”进行的。当你将一个对象赋值给一个新的变量时，你实际上是在创建一个新的引用（或指针），指向内存中已经存在的对象，而不是创建该对象的一个全新副本。
void main() {
  // 创建一个List
  List `<int>` originalList = [1, 2, 3];

  // 将List赋值给一个新的变量
  List `<int>` newList = originalList;

  // 修改原始List
  originalList.add(4);

  // 打印两个List，它们现在包含相同的元素
  print(originalList); // 输出: [1, 2, 3, 4]
  print(newList);     // 输出: [1, 2, 3, 4]

  // 因为originalList和newList引用的是同一个List对象
}
如果你想要修改一个List而不影响其他引用它的变量，你需要创建一个新的List对象，并将原始List的元素复制到新的List中。这可以通过多种方式完成，例如使用List.from()构造函数或扩展操作符（...）：

void main() {
  // 创建一个List
  List `<int>` originalList = [1, 2, 3];

  // 创建一个新的List，并将原始List的元素复制到新的List中
  List `<int>` newList = List.from(originalList); // 或者使用 newList = [...originalList];

  // 修改原始List
  originalList.add(4);

  // 打印两个List，它们现在包含不同的元素
  print(originalList); // 输出: [1, 2, 3, 4]
  print(newList);     // 输出: [1, 2, 3]

  // 因为originalList和newList现在引用的是不同的List对象
}

# 按钮点击事件中含有2个网络异步请求函数,这2个异步请求函数需要顺序执行.因此2个按钮触发事件函数要加async,2个异步函数的返回值应该为Future `<void>`(不返回任何值) 或Future `<T>` (返回一个类型值),然后再调用异步函数时候,前边加await.如yonghuxinxi.dart的删除用户按钮的事件函数中的代码.

# 对话框中的刷新可以用StatefulBuilder,或ValueListenableBuilder

# 不同版本的代码,新建一个分支.然后vscode提交源码,就会提交给新的分支.0

# 获取当前组件的宽高,使用组件LayoutBuilder的constraints.maxWidth.函数 MediaQuery.of(context).size.width获取的是整个屏幕的宽度.

# 2个SingleChildScrollView嵌套时,内外层SingleChildScrollView都套一个scrollbar,则最里层的SingleChildScrollView无法使用滚动条下拉拖动.解决方法,去除最里层的scrollbar

# 重装机后应该克隆git仓库项目代码

# 项目的文件名必须和其中的类名一致.菜单的url必须是路径/文件名也就是/路径/类名.

# flutter doctor 报错Error: Unable to find git in your PATH

### 结论

如果不是信得过的文件夹Git会报错

方法1：将所有文件夹都指定为安全的

PS C:\Users\UserName> git config --global --add safe.directory '*'
方法2：将指定文件夹定为安全的

git config --global --add safe.directory C:\Users\UserName\flutter\

# vscode推送git太慢.https://blog.csdn.net/qq_41375318/article/details/131203836

# flutter doctort提示git没有被设置时候,查看下环境变量,如果已经存在,则右键运行vscode即可

# 修改flutter get hub的缓存位置,默认是在c,设置PUB_CACHE来设置依赖包的位置.

# flutter doctor报错GitHub.com访问超时,修改系统host文件

将以下全部复制粘贴到C:\Windows\System32\drivers\etc\hosts里面保存之后。

192.30.253.113    github.com

192.30.252.131 github.com

185.31.16.185 github.global.ssl.fastly.net

74.125.237.1 dl-ssl.google.com

173.194.127.200 groups.google.com

192.30.252.131 github.com
185.31.16.185 github.global.ssl.fastly.net

74.125.128.95 ajax.googleapis.com

192.30.255.112  github.com git
185.31.16.184 github.global.ssl.fastly.net
192.30.253.112    github.com
192.30.253.119    gist.github.com
151.101.184.133    assets-cdn.github.com
151.101.184.133    raw.githubusercontent.com
151.101.184.133    gist.githubusercontent.com
151.101.184.133    cloud.githubusercontent.com
151.101.184.133    camo.githubusercontent.com
151.101.184.133    avatars0.githubusercontent.com
151.101.184.133    avatars1.githubusercontent.com
151.101.184.133    avatars2.githubusercontent.com
151.101.184.133    avatars3.githubusercontent.com
151.101.184.133    avatars4.githubusercontent.com
151.101.184.133    avatars5.githubusercontent.com
151.101.184.133    avatars6.githubusercontent.com
151.101.184.133    avatars7.githubusercontent.com
151.101.184.133    avatars8.githubusercontent.com
————————————————

    版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/qq_56049468/article/details/133232380

# Article_xiang_qing()// id必须赋值,key不是必须赋值的,且id和key不限制赋值的先后顺序/因为是{}大括号为可选参数.()小括号和required是必选参数

# 按钮的事件或者初始化函数中都不能用context.watch `<Model1>`(),需要用  Provider.of `<Model1>`(context, listen: false).nickname

 // context.watch `<Model1>`().nickname, provider6.0.5这句会触发一个报错哦.
                大致意思是,这里的按钮事件不是刷新ui界面,因此不用watch监听外部的变化
                    Provider.of `<Model1>`(context, listen: false).nickname只获取nickname而不监听它的变化,不监听变化因此不用刷新ui.

//使用hide 隐藏 Response
import 'package:dio/dio.dart';
import 'package:get/get.dart' hide Response;

# listview滚动条始终显示外加一个滚动条控件Scrollbar,  thumbVisibility: true, //显示滚动条. isAlwaysShown   : true,//废弃了

# 在初始化initstate中使用provider的context避免报错.

    Provider.of`<Model1>`(context, listen: false).shaixuan(article_list);不要用Model1.watch().

#json转map.第三方response.data的返回值是list `<jsonmap>`,意思是json字符串.需要用json.decode把map字符串转为map
 ''''
  Map<dynamic, dynamic> gangwei = {}; //id,岗位名
 for (var ele in response.data["data"]["id_gangwei"]) {
            //json转map.给list `<jsonmap>`中的项添加一个键值,必须先把其中的jsonmap变成通过json.decode转成map

    Map a1 = json.decode(json.encode(
                ele)); //json.encode(ele)把ele转为map类型的字符串,再经过json.decode把map字符串转为map
            gangwei.addAll({a1["id"]: a1["gangwei"]});

    }
'''

# 设置颜色Color.fromARGB( 亮度固定255,r: 61,g: 177,b: 255).rgb来自色轮rgb模式下的值

# CheckboxListTile(//必须加到flexible中,才能以row形式显示哦

# setstate的使用

```
  if (mounted) {
            setState(
                () {}); //报错:setState()called after dispose()(lifecyclestate:defunct, not mounted)

          } else {
            return;
          }
```

# list.insertAll(插入的位置,list `<dynamic>`)和list.insert(插入的位置,dynamic)的区别.前者插入的list `<dynamic>`列表中的多个元素会依次增加到list的末尾;而后者是把插入的dynamic元素作为一个整体插入,最终得到的是一个List `<List>`的嵌套类型

# print(变量.runtimeType);获取变量类型.dio的请求返回数据类型是List `<dynamic>`

# 20.await的执行.如按钮的点击获取dio的网络数据的函数fun1.

await所修饰的本行语句执行后会等待网络请求的返回,并且await下方所有的本函数体fun1所在的语句都会停止执行,直到网络请求返回了才会继续执行func1体的其他语句;

如果,fun1含在函数fun2中,即fun2中调用fun1.fun1未写await,fun1所在函数 内部会停止执行除await语句外的其他代码,但会跳到fun1外的函数fun2继续执行调用fun1函数下一行代码,当网络请求返回时,会在fun1中继续执行,而不会再回到fun2执行,因为fun2的其余代码已经执行过了.

如果fun2调用fun1时,fun1写了await,且fun2函数名后方跟着async,则执行过程是fun1中执行到await语句会停止等待,不会执行fun1其他代码,也不会跳到fun2执行.因为fun2遇到await也会停止执行其他代码的,但会跳到fun2的外层函数去执行.直到fun1网络请求返回后继续执行fun1函数块,然后执行fun2剩下的未执行代码.
综上所述:fun2调用fun1不写await是不阻塞fun2执行的,无法获取fun1的返回值,所以调用fun1时也要写await.如 fun2{

  var a=fun1(await 网络请求;return a);
  print(a);//因为fun1未写await,所以这行代码在等待fun1内部的await语句等待网络返回数据时,不会继续执行return a.但会跳出fun1继续执行外部的print(a),外部无法获得返回有效值a.想获得返回正确的值a,fun1就要加上await. 直到网络请求完成,就重新回到语句1执行剩下的语句.然后在返回执行语句2的函数的代码.

# 19 自动生成children:

```
List.generate(20, (index) {return Tex("$index");
 }),
```

18转换器
转换器Transformer 用于对请求数据和响应数据进行编解码处理。Dio实现了一个默认转换器DefaultTransformer作为默认的 Transformer. 如果你想对请求/响应数据进行自定义编解码处理，可以提供自定义转换器，通过 dio.transformer设置。

请求转换器 Transformer.transformRequest(...) 只会被用于 'PUT'、 'POST'、 'PATCH'方法，因为只有这些方法才可以携带请求体(request body)。但是响应转换器 Transformer.transformResponse() 会被用于所有请求方法的返回数据。

Flutter中设置
如果你在开发Flutter应用，强烈建议json的解码通过compute方法在后台进行，这样可以避免在解析复杂json时导致的UI卡顿。

注意，根据笔者实际测试，发现通过compute在后台解码json耗时比直接解码慢很多，建议开发者仔细评估。

// 必须是顶层函数
_parseAndDecode(String response) {
  return jsonDecode(response);
}

parseJson(String text) {
  return compute(_parseAndDecode, text);
}

void main() {
  ...
  // 自定义 jsonDecodeCallback
  (dio.transformer as DefaultTransformer).jsonDecodeCallback = parseJson;
  runApp(MyApp());
}
17  ??=，如果变量没有赋值才进行赋值，否则不进行赋值.
b ??= 10;//b赋值了就不赋值了,如果没有赋值就赋值为10

var i=2;var j=i??10;此时j=2,因为i赋值了.如果没有var i=2,那j=10.

定一个可为空的变量a,
String? a;//?表示a可以为空,!表示一定不为空
a??=3;//如果a没有被赋值,也就代表a为null,那么a赋值为3.
Text(a??="空")//a不赋值时候,赋值为空.

16 问号表达式a > 9 ? 9 : 1, 解释a>9成立时a=9,否则为a=1

15.修改后台左侧菜单名称.需要修改数据表admin_menu的菜单名和left_menu.dart中的menu_admin_class的列表.

14.LayoutBuilder可以获取设备的宽高信息,内部包含的部件可以通过constraints.maxWidth,获取LayoutBuilder的宽高尺寸.可以使用 LayoutBuilder 来根据设备的尺寸来实现响应式布局

13.datatable修改数据信息后,只更新单独一行数据,而非全部更新.

-11 修改编辑器的_onImagePickCallback和webImagePickImpl,增加上传图片到服务器获取url的功能

-10 listview屏蔽滚动条mmmm0000000000

 return **ScrollConfiguration(**

 **behavior:ScrollConfiguration.of(context).copyWith(scrollbars:false),**

 **child:**ListView(controller:controller,

    children: [

    Column(

    children:List`<Widget>`.generate(

    1,

    (index) =>Text("${index}"),

    ))

    ]));

-9 展示编辑器的内容,lib\admin\left_menu\pages\widgets\demo_scaffold.dart修改64行增加

    var s= widget.documentFilename.replaceAll('\n', '\\n');//把其中的转义字符\n转成非转义的,就是\\n.因为json中不能有转义字符存在

    final doc = Document.fromJson(jsonDecode(s));

-8.新版编辑器VisualEditor 提示:"!kIsWeb,Please provide EmbedBuilder for Web"的处理方法:
D:\flutter\.pub-cache\git\visual-editor-6497c03070365acf6707400bb41615ddb6f669d4\lib\embeds\widgets\default-embed-builder.dart 屏蔽29行assert(!kIsWeb, 'Please provide EmbedBuilder for Web');

# -7,局部刷新组件.使用context.watch `<Model1>`(),可以替代contex.read和consumer的局部刷新组合哦) 或者使用FutureBuilder, StreamBuilder `<dynamic>`,StatefulBuilder或者单独把显示的部件做成有状态的组件,然后内部使用setstate就会只刷新此包裹的return组件部分了. streambuilder主要用于数据加载时不同阶段的进度状态展示,例如显示加载中,加载完成等.在无状态组件中刷新ui可以用ValueNotifier只针对数值变化的局部刷新(参考用户信息页面).statefulbuilder[用法见article_xiang_qing.dart,内部可以通过   再其他按钮组件中调用 _reloadTextSetter(() {});来实现 statefulbuilder刷新] .通过异步网络请求获取的数据,使用FutureBuilder, StreamBuilder.在首次显示页面时,不会报错,即便没有数据会按照我们设置的组件进行显示.而statefulbuilder会报错,因为没有数据.

-6获取屏幕宽高

final size =MediaQuery.of(context).size;
final width =size.width;
final height =size.height;

-5

跨域处理,浏览器安装一个插件Moesif Origin & CORS Changer.或者使用shelf_proxy插件

-4// ignore: undefined_prefixed_name,可以忽略web插件注册的错误

-3左侧菜单增加项.数据库admin_menu中添加菜单名字和url,然后在casbin_rule中添加规则,修改left_menu.dart中的Map<String, Widget> menu_admin_class变量,添加菜单页面名称和对应类名,在left_menu->pages中添加对应菜单类

-2.flex:0且内部控件为长宽都是0才不会显示.

-1.视频的全屏使用js在移动平台需要屏蔽.屏蔽dart文件的按钮触发全屏的代码和import'dart:js'asjs;

0.在web下创建js文件夹,贴入js代码,文件名为js.js:

functionjs_fullscreen(index){

  //元素id2实现全屏

  // var element= document.getElementById("videoElement-2");//id会随着切换而变化

  varelement= document.getElementsByTagName("video")[index];//返回的是数组

  console.log(element);

  if (element.requestFullscreen) {

    element.requestFullscreen();

  }elseif (element.mozRequestFullScreen) {

    element.mozRequestFullScreen();

  }elseif (element.msRequestFullscreen) {

    element.msRequestFullscreen();

  }elseif (element.webkitRequestFullscreen) {

    element.webkitRequestFullScreen();

  }

keyEvent(122)

 return"js_ok";

}

然后在web->index.html中body结束标签后引入test.js文件<scriptsrc="js/test1.js"type="application/javascript">`</script>`

flutter使用import'dart:js'asjs;import

1flutter桌面版运行报错的处理  [Releases · microsoft/vswhere · GitHub](https://github.com/microsoft/vswhere/releases)下载vswhere替换C:\Program Files\Microsoft Visual Studio\2022\Preview\Common7\IDE进行替换
flutter浏览器遇到跨域问题是因为gf后端没有设置跨域响应.设置下跨域的中间件就欧克了
    group.Middleware(
                                        service.Middleware().Ctx,
                                        ghttp.MiddlewareCORS,
                                    )
 ~~同时浏览器的也要设置,**G:\flutter\flutter_windows_3.0.1-stable\flutter\packages\flutter_tools\lib\src\web\**chrome.dart的211行增加~~

 ~~'--disable-translate',//原有的代码~~

 ~~'--disable-web-security//新增加的代码~~

~~然后删除**G:\flutter\flutter_windows_3.0.1-stable\flutter\bin\cache**下的2个文件flutter_tools.snapshot,flutter_tools.stamp~~

验证是否允许跨域的代码,在浏览器的控制台输入,然后回车执行

var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://127.0.0.1:8199/upload_file/0b8f968c-6fbb-46f9-8b8c-5f6448753184.jpeg');
xhr.send(null);
xhr.onload = function(e) {
    var xhr = e.target;
    console.log(xhr.responseText);}

2资源位置.在根目录/assets/images中.

**3 包的路径：/表示lib目录下   ./同级目录或者直接文件名即可   ../上级目录**

 如：lib/w.dart  ,包的引入为 import'/w.dart';

 **lib/amdin/w.dart下的引入包的路径为：import'/admin/w.dart';**

  body:Container(

    //alignment: Alignment.center,

    padding:EdgeInsets.all(6.0),

    width:double.infinity,

    child:Column(

    children:`<Widget>`[

    TextButton(

    onPressed: () {

    if (!maps0caidan0index.keys.contains(caidan[0])) {

    //当前菜单不存在时,添加tab中显示

    maps0caidan0index[caidan[0]] =

    context.read`<Model1>`().tabsname_admin.length;

    context.read`<Model1>`().change_caidan_admin("网站信息",

    wangzhanxinxi());

    tabController1.dispose();

    tabController1=TabController(

    length:context.read`<Model1>`().tabsname_admin.length,

    vsync:this);

    //   Tab1();

// 2秒后跳转至新的页面

    Future.delayed(Duration(milliseconds:200), () {

    //  print(   tabController1.index);

    tabController1.index=

    context.read`<Model1>`().tabsname_admin.length-1;

    //  print(   tabController1.index);//设置默认菜单索引

    });

    } else {

    //已经存在了的菜单,则选中当前菜单的索引

    tabController1.index=

    maps0caidan0index[caidan[0]]!;

    }

    },

    child:Text("网站信息"),

    ),

    Consumer(builder: (context, Model1model1, child) {

    returnTextButton(

    onPressed: () {

    model1.change_caidan_admin("上传设置",

    // Row(

    //   // mainAxisAlignment: MainAxisAlignment.end,

    //   children:`<Widget>`[

    //     const Text("上传设置"),

    //     IconButton(

    //       splashRadius: 9, //决定了图标按钮悬浮的阴影面积半径

    //       iconSize: 30,

    //       padding: const EdgeInsets.all(

    //           2.0), //图标按钮的边距

    //       onPressed: () {},

    //       icon: const Icon(

    //         Icons.add,

    //         color: Colors.amber,

    //       ),

    //     ),

    //   ],

    // ),

    wangzhanxinxi());

    tabController1.dispose();

    tabController1=TabController(

    length:context.read`<Model1>`().tabsname_admin.length,

    vsync:this);

// 2秒后跳转至新的页面

    Future.delayed(Duration(milliseconds:200), () {

    tabController1.index=

    context.read`<Model1>`().tabsname_admin.length-

    1; //设置默认菜单索引

    });

    },

    child:Text("上传设置"));

    }),

    TextButton(

    onPressed: () {

    context.read`<Model1>`().change_caidan_admin("文件存储",

    // Row(

    //   // mainAxisAlignment: MainAxisAlignment.end,

    //   children:`<Widget>`[

    //     const Text("文件存储"),

    //     IconButton(

    //       splashRadius: 9, //决定了图标按钮悬浮的阴影面积半径

    //       iconSize: 30,

    //       padding:

    //           const EdgeInsets.all(2.0), //图标按钮的边距

    //       onPressed: () {},

    //       icon: const Icon(

    //         Icons.add,

    //         color: Colors.amber,

    //       ),

    //     ),

    //   ],

    // ),

    wangzhanxinxi());

    tabController1.dispose();

    tabController1=TabController(

    length:context.read`<Model1>`().tabsname_admin.length,

    vsync:this);

// 2秒后跳转至新的页面

    Future.delayed(Duration(milliseconds:200), () {

    tabController1.index=

    context.read`<Model1>`().tabsname_admin.length-

    1; //设置默认菜单索引

    });

    },

    child:Text("文件存储")),

    ],

    )),

    isExpanded:_isExpanded, // 设置面板的状态，true展开，false折叠

*代码段自动生成组件100个text组件
 children: List `<Widget>`.generate(100, (int i) {
                              return LayoutBuilder(
                                  builder: (context, constraints) {
                                return Text("12");
                              });
                            })

滚动图的源码修改 lib\src\swiper_control.dart

  Widget buildButton(SwiperPluginConfig config, Color color, IconData iconDaga,
      int quarterTurns, bool previous) {
    return

    Padding(
          padding: padding,
          child: RotatedBox(
            quarterTurns: quarterTurns,
            child: FloatingActionButton(
              onPressed: () { if (previous) {
          config.controller.previous(animation: true);
        } else {
          config.controller.next(animation: true);
        }},
              child:   Icon(iconDaga),
            ),

    )

    );
  }

* wrap中的控件如果不同类型,想要中心水平对齐.
  Wrap(
  spacing: 30.0, // 主轴(水平)方向间距
  runSpacing: 4.0, // 纵轴（垂直）方向间距

  crossAxisAlignment:
  WrapCrossAlignment
  .center, //可解决不同组件的中心对齐
  alignment: WrapAlignment.center,

# 关于布局.container->row/column->expanded->wrap->row/column ,expanded-wrap必须一起,并且expanded必须在row或column内,否则报错:Another exception was thrown: Incorrect use of ParentDataWidget.    Column里面嵌套Column、ListView、EasyRefresh等空间具有无限延展性等控件时，每一层都需要用Expanded包裹，漏掉一层都不行.

---

# 让text换行可以直接在外边用expand包裹

# container-listview-card-row-row-expanded,此布局会提示"不正确的父组件".问题出在expanded上,它没有获取到宽度.应该在row外加一个IntrinsicWidth.即container-listview-card-row-IntrinsicWidth-row-expanded或者每一个expaned外层都加IntrinsicWidth,即container-listview-card-row-row-IntrinsicWidth-expanded.组件IntrinsicWidth的功能是获取上层父类控件的最小宽度.

# 滚动视图外层必须有高限制,但滚动视图在根上的第一个就没事.

# 在Flutter的ListView的子View中，你可以在Row中使用Expanded填充水平方向的剩余空间，而无法在Column中使用Expanded填充垂直方向的剩余空间。原因是ListView垂直方向的计算是包裹子View的，也就是说子View必须有一个明确的高度，或者尽可能小的高度，而不能是无限高。Row是横向排列，在Row中使用Expanded是填充水平方向的剩余空间，这和ListView的这一特性没有冲突，可以使用。而Column是竖直排列，在Column中使用Expanded是填充竖直方向的剩余空间，这将和ListView的这一特性发生冲突，因为ListView将无法计算自己的子View的高度。SingleChildScrollView或者listview外层必须有固定的宽高,否则不显示.

# //列>行-expanded自动扩展-wrap流式布局组件-多个子container(给定宽)-行>expanded>wrap>多个子container(给定宽),可实现多个行及行内元素的流式布局.效果是按行可以流式布局,在缩小范围行内元素也是流式布局.

# 根据岗位名称获取岗位id

    String
                                                                  gangwei_id =
                                                                  "";
                                                              List`<dynamic>`
                                                                  list_values =
                                                                  map_gangwei
                                                                      .values
                                                                      .toList(); //把map_gangwei的值变成list

    List`<dynamic>`
                                                                  list_keys =
                                                                  map_gangwei
                                                                      .keys
                                                                      .toList(); //把map_gangwei的键变成list

    for (int i = 0;
                                                                  i <
                                                                      list_values
                                                                          .length;
                                                                  i++) {

    if (list_values[
                                                                        i] ==
                                                                    tabsname_admin[
                                                                        value]) {
                                                                  //如果list_values的元素=当前选项的岗位名称,则取list_keys的值,这个值就是岗位_id

    gangwei_id =
                                                                      list_keys[
                                                                              i]
                                                                          .toString();
                                                                }
                                                              }
                                                              print(gangwei_id);

# //根据给定的文章分类名,获取文章分类id

    int article_fenlei_id =
                                                                  0;
                                                              for (var i1 = 0;
                                                                  i1 <
                                                                      article_fenlei_name_id
                                                                          .length;
                                                                  i1++) {
                                                                //当给定tabsname_admin[value]文本=从库中获取的article_fenlei_name_id[ i1]["fenlei_name"]分类名时,获取文本对应的id
                                                                if (tabsname_admin[
                                                                        value] ==
                                                                    article_fenlei_name_id[
                                                                            i1][
                                                                        "fenlei_name"]) {
                                                                  // print(
                                                                  //     "文章分类id:");
                                                                  // print(article_fenlei_name_id[
                                                                  //         i1]
                                                                  //     ["id"]);
                                                                  article_fenlei_id =
                                                                      article_fenlei_name_id[
                                                                              i1]
                                                                          [
                                                                          "id"];
                                                                  break;
                                                                }
                                                              }
                                                              print(
                                                                  article_fenlei_id);

# 给组件添加 key: UniqueKey(),//强制刷新组件.偶尔发现有时候,其中的futurebuilder的listview不刷新.因此使用  key: UniqueKey(),来刷新外层的组件,进而刷新listviews.FutureBuilder是一个StatefulWidget控件，如果父节点重绘rebuild那么FutureBuilder也会重绘

# init的网络请求 get_fenlei中初始化tabcontroller报错Another exception was thrown: LateInitializationError: Field 'tabController2' has not been initialized..这时在网络请求函数 get_fenlei中初始化一次,然后在init中再初始化一次.2次代码一样.如

 '''  Center_user.dart中代码如下
 init初始化中:
    get_fenlei().then((value) {
      // tabController2 = TabController(length: tabsname_admin.length, vsync: this);
    });
    tabController2 = TabController(length: tabsname_admin.length, vsync: this);

 其中get_fenlei函数中还有一次 tabController2 = TabController(length: tabsname_admin.length, vsync: this);
 '''
 或者 在定义时候直接赋值:  late TabController tabController2 =
      TabController(length: tabsname_admin.length, vsync: this); //需要定义一个Controller
      然后再init初始化函数中再次赋值tabController2 =
      TabController(length: tabsname_admin.length, vsync: this);
